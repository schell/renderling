//! Provides convenient wrappers around renderling shader linkage.
//!
//! # Warning!
//! Please don't put anything in `crates/renderling/src/linkage/*`.
//! The files there are all auto-generated by the shader compilation machinery.
//! It is common to delete everything in that directory and regenerate.
use std::sync::Arc;

pub mod atlas_blit_fragment;
pub mod atlas_blit_vertex;
pub mod bloom_downsample_fragment;
pub mod bloom_mix_fragment;
pub mod bloom_upsample_fragment;
pub mod bloom_vertex;
pub mod brdf_lut_convolution_fragment;
pub mod brdf_lut_convolution_vertex;
pub mod compute_copy_depth_to_pyramid;
pub mod compute_copy_depth_to_pyramid_multisampled;
pub mod compute_culling;
pub mod compute_downsample_depth_pyramid;
pub mod cubemap_sampling_test_fragment;
pub mod cubemap_sampling_test_vertex;
pub mod debug_overlay_fragment;
pub mod debug_overlay_vertex;
pub mod di_convolution_fragment;
pub mod generate_mipmap_fragment;
pub mod generate_mipmap_vertex;
pub mod light_tiling_compute_tiles;
pub mod light_tiling_compute_tiles_multisampled;
pub mod light_tiling_depth_pre_pass;
pub mod prefilter_environment_cubemap_fragment;
pub mod prefilter_environment_cubemap_vertex;
pub mod renderlet_fragment;
pub mod renderlet_vertex;
pub mod shadow_mapping_fragment;
pub mod shadow_mapping_vertex;
pub mod skybox_cubemap_fragment;
pub mod skybox_cubemap_vertex;
pub mod skybox_equirectangular_fragment;
pub mod skybox_vertex;
pub mod tonemapping_fragment;
pub mod tonemapping_vertex;

pub struct ShaderLinkage {
    pub module: Arc<wgpu::ShaderModule>,
    pub entry_point: &'static str,
}

#[cfg(test)]
mod test {
    use naga::valid::ValidationFlags;

    #[test]
    // Ensure that the shaders can be converted to WGSL.
    // This is necessary for WASM using WebGPU, because WebGPU only accepts
    // WGSL as a shading language.
    fn validate_shaders() {
        fn validate_src(path: &std::path::PathBuf) {
            log::info!("validating source");
            log::info!("  reading '{}'", path.display());
            let bytes = std::fs::read(path).unwrap();
            log::info!("  {:0.2}k bytes read", bytes.len() as f32 / 1000.0);
            let opts = naga::front::spv::Options::default();
            let module = match naga::front::spv::parse_u8_slice(&bytes, &opts) {
                Ok(m) => m,
                Err(e) => {
                    log::error!("{e}");
                    panic!("SPIR-V parse error");
                }
            };
            log::info!("  SPIR-V parsed");
            let mut validator =
                naga::valid::Validator::new(Default::default(), naga::valid::Capabilities::empty());
            let is_valid;
            let info = match validator.validate(&module) {
                Ok(i) => {
                    is_valid = true;
                    log::info!("  SPIR-V validated");
                    i
                }
                Err(e) => {
                    log::error!("{}", e.emit_to_string(""));
                    is_valid = false;
                    let mut validator = naga::valid::Validator::new(
                        ValidationFlags::empty(),
                        naga::valid::Capabilities::empty(),
                    );
                    validator.validate(&module).unwrap()
                }
            };
            let wgsl = naga::back::wgsl::write_string(
                &module,
                &info,
                naga::back::wgsl::WriterFlags::empty(),
            )
            .unwrap();
            log::info!("  output WGSL generated");

            let print_var_name = path
                .file_stem()
                .unwrap()
                .to_str()
                .unwrap()
                .replace('-', "_");
            let maybe_output_path = if std::env::var("print_wgsl").is_ok() || !is_valid {
                let dir = std::path::PathBuf::from("../../test_output");
                std::fs::create_dir_all(&dir).unwrap();
                let output_path = dir.join(print_var_name).with_extension("wgsl");
                log::info!("writing WGSL to '{}'", output_path.display());
                Some(output_path)
            } else {
                log::info!("  to save the generated WGSL, use an env var 'print_wgsl=1'");
                None
            };

            if let Some(output_path) = maybe_output_path {
                std::fs::write(&output_path, &wgsl).unwrap();
                log::info!("  wrote generated WGSL to {}", output_path.display());
            }

            if !is_valid {
                panic!("SPIR-V validation error");
            }

            let module = match naga::front::wgsl::parse_str(&wgsl) {
                Ok(m) => m,
                Err(e) => {
                    log::error!("{}", e.emit_to_string(&wgsl));
                    panic!("wgsl parse error");
                }
            };
            log::info!("  output WGSL parsed");
            let mut validator =
                naga::valid::Validator::new(Default::default(), naga::valid::Capabilities::empty());
            let _info = match validator.validate(&module) {
                Ok(i) => i,
                Err(e) => {
                    log::error!("{}", e.emit_to_string(&wgsl));
                    panic!("wgsl validation error");
                }
            };
            log::info!("  wgsl output validated");
        }

        let may_entries = std::fs::read_dir("src/linkage").unwrap();
        for may_entry in may_entries {
            let entry = may_entry.unwrap();
            let path = entry.path();
            let ext = path.extension().unwrap().to_str().unwrap();
            if let Ok(filename) = std::env::var("only_shader") {
                let stem = path.file_stem().unwrap().to_str().unwrap();
                if filename != stem {
                    log::info!(
                        "  '{}' doesn't match 'only_shader' env '{}', skipping",
                        filename,
                        stem
                    );
                    continue;
                }
            }
            if ext == "spv" {
                validate_src(&path);
            }
        }
    }
}
